{"ast":null,"code":"import _objectSpread from \"D:\\\\SortaApp\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/objectSpread\";\nimport flightData from './../data.json';\nimport { transformFlightDates } from './utils'; //Using a graph algorithm to recursively explore all the connected nodes and find all connected flight paths\n\nfunction paths({\n  graph = [],\n  from,\n  to,\n  date\n}, path = []) {\n  const linkedNodes = connectedNodes(nodes.bind(null, graph));\n  return explore(from, to);\n\n  function explore(currNode, to, paths = [], originalNode) {\n    path.push(originalNode || currNode);\n\n    for (let linkedNode of linkedNodes(currNode)) {\n      if (linkedNode.destination === to) {\n        let result = path.slice(); // copy values\n\n        result.push(_objectSpread({}, linkedNode));\n        paths.push(result);\n        continue;\n      } // do not traverse paths already explored\n\n\n      if (!hasEdgeBeenTraversedInPath({\n        edge: {\n          from: currNode,\n          to: linkedNode.destination\n        },\n        path: path.map(a => a && a.destination ? a.destination : a)\n      })) {\n        explore(linkedNode.destination, to, paths, linkedNode);\n      }\n    }\n\n    path.pop(); // sub-graph fully explored \n\n    return paths;\n  }\n}\n/** \r\n* Get all nodes linked \r\n* to from `node`.\r\n*/\n\n\nfunction nodes(graph, node) {\n  const list = graph.reduce((p, c) => {\n    c.origin === node && p.push({\n      destination: c.destination,\n      config: _objectSpread({}, c)\n    });\n    return p;\n  }, []);\n  return list;\n}\n/**\r\n* Has an edge been followed \r\n* in the given path?\r\n*/\n\n\nfunction hasEdgeBeenTraversedInPath({\n  edge,\n  path\n}) {\n  var indices = allIndices(path, edge.from);\n  return indices.some(i => path[i + 1] === edge.to);\n}\n/**\r\n* Utility to get all indices of \r\n* values matching `val` in `arr`.\r\n*/\n\n\nfunction allIndices(arr, value) {\n  var indices = [],\n      i;\n\n  for (i = 0; i < arr.length; i++) {\n    if (arr[i] === value) {\n      indices.push(i);\n    }\n  }\n\n  return indices;\n}\n/**\r\n* Avoids recalculating flight route \r\n* nodes.\r\n*/\n\n\nfunction connectedNodes(fn) {\n  const flightCache = new Map();\n  return function () {\n    var key = JSON.stringify(arguments);\n    var cached = flightCache.get(key);\n\n    if (cached) {\n      return cached;\n    }\n\n    cached = fn.apply(this, arguments);\n    flightCache.set(key, cached);\n    return cached;\n  };\n}\n\nfunction filterPaths(paths, date, numOfPassengers) {\n  const list = paths.filter(path => {\n    return isSameDestination(path);\n  });\n  const finalPaths = list.filter(path => {\n    return checkLayoverCriteria(path, date);\n  });\n  const transformedPaths = {\n    nonStopFlights: [],\n    multiStopFlights: []\n  };\n  finalPaths.forEach((path, index) => {\n    if (path.length === 2) {\n      transformedPaths.nonStopFlights.push(_objectSpread({}, path[1].config, {\n        price: path[1].config.price * (parseInt(numOfPassengers) || 1)\n      }));\n    } else {\n      let totalFare = 0,\n          multiFlights = [],\n          layovers = path.length - 1;\n\n      for (let i = 1; i < path.length; i++) {\n        multiFlights.push(_objectSpread({}, path[i].config));\n        totalFare += path[i].config.price;\n      }\n\n      transformedPaths.multiStopFlights.push({\n        cumulativeFlight: {\n          origin: path[0],\n          destination: path[layovers].destination,\n          date: path[1].config.date,\n          departureTime: path[1].config.departureTime,\n          departureTimeStamp: path[1].config.departureTimeStamp,\n          dayChange: path[1].config.date !== path[layovers].config.date,\n          totalFare: totalFare * (parseInt(numOfPassengers) || 1)\n        },\n        flights: multiFlights\n      });\n    }\n\n    return transformedPaths;\n  });\n  return transformedPaths;\n}\n\nfunction checkLayoverCriteria(path, startDate) {\n  let lowerLayover = false;\n\n  if (path.length > 1 && path[1].config.date !== startDate.replace(/-/g, '/')) {\n    return false;\n  }\n\n  for (let i = 0; i < path.length - 1; i++) {\n    if (typeof path[i] === \"object\" && typeof path[i + 1] === \"object\" && path[i + 1].config.departureTimeStamp - path[i].config.arrivalTimeStamp <= 1800000) {\n      lowerLayover = true;\n      break;\n    }\n  }\n\n  return !lowerLayover;\n}\n\nfunction isSameDestination(links) {\n  let duplicate = false;\n  let keys = {};\n\n  for (let i = 0; i < links.length; i++) {\n    const keyName = links[i] && links[i].destination ? links[i].destination : links[i];\n\n    if (keys.hasOwnProperty(keyName)) {\n      duplicate = true;\n      break;\n    }\n\n    keys[keyName] = links[i];\n  }\n\n  return !duplicate;\n}\n\nexport function findPaths({\n  flights = transformFlightDates(flightData),\n  criteria = {\n    origin: 'Bengaluru (BLR)',\n    destination: 'Delhi (DEL)'\n  }\n}) {\n  return filterPaths(paths({\n    graph: flights,\n    from: criteria.origin,\n    to: criteria.destination\n  }), criteria.date, criteria.numOfPassengers);\n}","map":{"version":3,"sources":["D:\\SortaApp\\src\\lib\\flightManager.js"],"names":["flightData","transformFlightDates","paths","graph","from","to","date","path","linkedNodes","connectedNodes","nodes","bind","explore","currNode","originalNode","push","linkedNode","destination","result","slice","hasEdgeBeenTraversedInPath","edge","map","a","pop","node","list","reduce","p","c","origin","config","indices","allIndices","some","i","arr","value","length","fn","flightCache","Map","key","JSON","stringify","arguments","cached","get","apply","set","filterPaths","numOfPassengers","filter","isSameDestination","finalPaths","checkLayoverCriteria","transformedPaths","nonStopFlights","multiStopFlights","forEach","index","price","parseInt","totalFare","multiFlights","layovers","cumulativeFlight","departureTime","departureTimeStamp","dayChange","flights","startDate","lowerLayover","replace","arrivalTimeStamp","links","duplicate","keys","keyName","hasOwnProperty","findPaths","criteria"],"mappings":"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","sourcesContent":["import flightData from './../data.json';\r\nimport { transformFlightDates } from './utils';\r\n\r\n//Using a graph algorithm to recursively explore all the connected nodes and find all connected flight paths\r\nfunction paths({ graph = [], from, to, date }, path = []) {\r\n  const linkedNodes = connectedNodes(nodes.bind(null, graph));\r\n  return explore(from, to);\r\n\r\n  function explore(currNode, to, paths = [], originalNode) {\r\n    path.push(originalNode || currNode);\r\n    for (let linkedNode of linkedNodes(currNode)) {\r\n      if (linkedNode.destination === to) {\r\n        let result = path.slice(); // copy values\r\n        result.push({ ...linkedNode });\r\n        paths.push(result);\r\n        continue;\r\n      }\r\n      // do not traverse paths already explored\r\n      if (!hasEdgeBeenTraversedInPath({\r\n        edge: {\r\n          from: currNode,\r\n          to: linkedNode.destination\r\n        },\r\n        path: path.map(a => a && a.destination ? a.destination : a)\r\n      })) {\r\n        explore(linkedNode.destination, to, paths, linkedNode);\r\n      }\r\n    }\r\n    path.pop(); // sub-graph fully explored \r\n\r\n    return paths;\r\n  }\r\n}\r\n\r\n/** \r\n* Get all nodes linked \r\n* to from `node`.\r\n*/\r\nfunction nodes(graph, node) {\r\n  const list = graph.reduce((p, c) => {\r\n    (c.origin === node) && p.push({ destination: c.destination, config: { ...c } });\r\n    return p;\r\n  }, []);\r\n  return list;\r\n}\r\n\r\n/**\r\n* Has an edge been followed \r\n* in the given path?\r\n*/\r\nfunction hasEdgeBeenTraversedInPath({ edge, path }) {\r\n  var indices = allIndices(path, edge.from);\r\n  return indices.some(i => path[i + 1] === edge.to);\r\n}\r\n\r\n/**\r\n* Utility to get all indices of \r\n* values matching `val` in `arr`.\r\n*/\r\nfunction allIndices(arr, value) {\r\n  var indices = [],\r\n    i;\r\n  for (i = 0; i < arr.length; i++) {\r\n    if (arr[i] === value) {\r\n      indices.push(i);\r\n    }\r\n  }\r\n  return indices;\r\n}\r\n\r\n/**\r\n* Avoids recalculating flight route \r\n* nodes.\r\n*/\r\nfunction connectedNodes(fn) {\r\n  const flightCache = new Map();\r\n  return function () {\r\n    var key = JSON.stringify(arguments);\r\n    var cached = flightCache.get(key);\r\n    if (cached) {\r\n      return cached;\r\n    }\r\n    cached = fn.apply(this, arguments)\r\n    flightCache.set(key, cached);\r\n    return cached;\r\n  };\r\n}\r\n\r\nfunction filterPaths(paths, date, numOfPassengers) {\r\n\r\n  const list = paths.filter(path => {\r\n    return isSameDestination(path);\r\n  });\r\n\r\n  const finalPaths = list.filter(path => {\r\n    return checkLayoverCriteria(path, date);\r\n  });\r\n\r\n  const transformedPaths = {\r\n    nonStopFlights: [],\r\n    multiStopFlights: [],\r\n  }\r\n\r\n  finalPaths.forEach((path, index) => {\r\n    if (path.length === 2) {\r\n      transformedPaths.nonStopFlights.push({\r\n        ...path[1].config,\r\n        price: path[1].config.price * (parseInt(numOfPassengers) || 1)\r\n      })\r\n    }\r\n    else {\r\n      let totalFare = 0, multiFlights = [], layovers = path.length - 1;\r\n      for (let i = 1; i < path.length; i++) {\r\n        multiFlights.push({ ...path[i].config });\r\n        totalFare += path[i].config.price;\r\n      }\r\n\r\n      transformedPaths.multiStopFlights.push({\r\n        cumulativeFlight: {\r\n          origin: path[0],\r\n          destination: path[layovers].destination,\r\n          date: path[1].config.date,\r\n          departureTime: path[1].config.departureTime,\r\n          departureTimeStamp: path[1].config.departureTimeStamp,\r\n          dayChange: path[1].config.date !== path[layovers].config.date,\r\n          totalFare: totalFare * (parseInt(numOfPassengers) || 1)\r\n        },\r\n        flights: multiFlights\r\n      })\r\n    }\r\n\r\n    return transformedPaths;\r\n  });\r\n\r\n  return transformedPaths;\r\n}\r\n\r\nfunction checkLayoverCriteria(path, startDate) {\r\n  let lowerLayover = false;\r\n\r\n  if (path.length > 1 && (path[1].config.date !== startDate.replace(/-/g, '/'))) {\r\n    return false;\r\n  }\r\n\r\n  for (let i = 0; i < path.length - 1; i++) {\r\n    if (typeof path[i] === \"object\" && typeof path[i + 1] === \"object\" && path[i + 1].config.departureTimeStamp - path[i].config.arrivalTimeStamp <= 1800000) {\r\n      lowerLayover = true;\r\n      break;\r\n    }\r\n  }\r\n\r\n  return !lowerLayover;\r\n}\r\n\r\nfunction isSameDestination(links) {\r\n  let duplicate = false;\r\n  let keys = {};\r\n  for (let i = 0; i < links.length; i++) {\r\n    const keyName = links[i] && links[i].destination ? links[i].destination : links[i];\r\n    if (keys.hasOwnProperty(keyName)) {\r\n      duplicate = true;\r\n      break;\r\n    }\r\n    keys[keyName] = links[i]\r\n  }\r\n  return !duplicate;\r\n}\r\n\r\nexport function findPaths({ flights = transformFlightDates(flightData), criteria = { origin: 'Bengaluru (BLR)', destination: 'Delhi (DEL)' } }) {\r\n  return filterPaths(paths({\r\n    graph: flights,\r\n    from: criteria.origin,\r\n    to: criteria.destination,\r\n  }), criteria.date, criteria.numOfPassengers)\r\n}\r\n\r\n"]},"metadata":{},"sourceType":"module"}